<html>
<head>
<title>Lab: System calls</title>
<link rel="stylesheet" href="labs.css" type="text/css" />
<script src="js/jquery-1.10.2.min.js"></script>
<script src="guidance.js"></script>
</head>
<body>

<h1>Lab: system calls</h1>

<p>In the last lab you used system calls to write a few utilities. In
this lab you will add some new system calls to xv6, which will help
you understand how they work and will expose you to some of the
internals of the xv6 kernel.  You will add more system calls in later
labs.

<div class="prereq">
<p>Before you begin lab system calls, read Chapter 2 of
    the <a href="../xv6/book-riscv-rev1.pdf">xv6 book</a>, and
    Sections 4.3 and 4.4 of Chapter 4, and
  related source files:

  <ul>

    <li> The user-space "stubs" that route system calls into the kernel are in <tt>user/usys.S</tt>,
      which is generated by <tt>user/usys.pl</tt> when you run <tt>make</tt>.
      Declarations are in <tt>user/user.h</tt>

    <li> The kernel-space code that routes a system call to the
    kernel function that implements it
    is in <tt>kernel/syscall.c</tt> and <tt>kernel/syscall.h</tt>.

    <li> Process-related code is <tt>kernel/proc.h</tt> and <tt>kernel/proc.c</tt>.

  </ul>
</div>

<div class="question">
<p>In this lab, there are several questions for you to answer. Questions are in boxes with a light orange background. 
Write each question and its answer in your notebook. Take photo(s) of your questions/answers and submit the photo(s) on Canvas.
<p>The Linux <tt>grep</tt> command can be helpful on C programming using Linux with a terminal and on some questions. For example, suppose a question asks you about the <tt>struct proc</tt>. You can discover the definition and uses of the <tt>struct proc</tt> by issuing the following Linux <tt>grep</tt> command in the <tt>kernel</tt> directory.
<pre>
$ <kbd>grep syscall *.c</kbd>
syscall.c:#include "syscall.h"
syscall.c:// An array mapping syscall numbers from syscall.h
syscall.c:static uint64 (*syscalls[])(void) = {
syscall.c:syscall(void)
syscall.c:  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
syscall.c:    p->trapframe->a0 = syscalls[num]();
trap.c:    syscall();
trap.c:  // send syscalls, interrupts, and exceptions to uservec in trampoline.S
% <kbd>grep syscall *.h</kbd>
defs.h:// syscall.c
defs.h:void            syscall();
</pre>
</div>
<div class="required">
<p>In the directory of your xv6-labs, create two files: <b>answers-syscall.txt</b> and <b>time.txt</b> that I may use 
if I run your code using your zip file submission. The answers-syscall.txt is a blank file. The time.txt file contains
the number of hours you spent on the lab.
<pre>
$ echo > answers-syscall.txt
$ echo 8 > time.txt
</pre>
</div>

<style>
table.syscalls {
    font-family: arial, helvetica;
    font-size: 10pt;
    empty-cells: show;
    border: 1px solid #000000;
    border-collapse: collapse;
}
table.syscalls tr td {
    border: 1px solid #aaaaaa;
}
table.syscalls tr {
    vertical-align: top;
    height: auto;
    background: #eeeeee;
}
table.syscalls thead tr {
    text-align: center;
    background: #444444;
    color: #ffffff;
    height: auto;
    font-weight: bold;
}
.lecture {
    background: #ffffaa;
}
.holiday {
    background: #ccffcc;
}
.special {
    background: #aaaaff;
}
.important {
    background: #ffaaaa;
}
.reading {
    color: #3333ff;
}
.deadline {
    color: #ff0000;
}
.hwdue {
    color: #ff0000;
}
.assignment {
    color: #0aa00a;
}
.date {
    color: #444444;
}
</style>
<table class="syscalls" cellspacing="0" cellpadding="6" width="100%">
 <thead>
  <tr>
   <td width="20%">Xv6 System Call</td><td width="80%">Description</td>
  </tr>
 </thead>


<p>Xv6 has a small collection of system calls, which are used to create utility programs. Using the system calls, you can create programs that open, close, and read files; create and delete files and directories; create processes; communicate between processes using pipes, read, and write; and execute programs. The API for Xv6 system calls are shown in yellow in the following table. In this lab you create the Xv6 system calls shown in red.
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int fork()</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Create a process, return child's PID.  </span><br /> </td>
</tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int exit(int status)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Terminate the current process; status reported to wait(). No return. Wait for a child to exit; exit status in *status; returns child PID. Terminate process PID. Returns 0, or -1 for error.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int wait(int *status)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Wait for a child to exit; exit status in *status; returns child PID.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int kill(int pid)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Terminate process PID. Returns 0, or -1 for error.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int getpid()</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Return the current process's PID.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int sleep(int n)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Pause for n clock ticks.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int exec(char *file, char *argv[])</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Load a file and execute it with arguments; only returns if error.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>char *sbrk(int n)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Grow process's memory by n bytes. Returns start of new memory. 
The C runtime function <tt>malloc()</tt> calls <tt>sbrk()</tt> to get space for the heap. 
</tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int open(char *file, int flags)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Open a file; flags indicate read/write; returns an fd (file descriptor). </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int write(int fd, char *buf, int n)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Write n bytes from buf to file descriptor fd; returns n.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int read(int fd, char *buf, int n)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Read n bytes into buf; returns number read; or 0 if end of file. Release open file fd.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int close(int fd)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Release open file fd. </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int dup(int fd)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Return a new file descriptor referring to the same file as fd.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int pipe(int p[])</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Create a pipe, put read/write file descriptors in p[0] and p[1]. Change the current directory.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int chdir(char *dir)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Change the current directory. </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int mkdir(char *dir)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Create a new directory.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int mknod(char *file, int, int)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Create a device file.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int fstat(int fd, struct stat *st)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Place info about an open file into *st.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int stat(char *file, struct stat *st)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Place info about a named file into *st.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int link(char *file1, char *file2)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Create another name (file2) for the file file1.  </tr>
<tr>
  <td id="fork" class="lecture"><span class="date"> <code>int unlink(char *file)</code> </span><br /> </td>
  <td id="forkdescr" class="reading"><span class="date"> Remove a file.</span><br /> </td>
</tr>
<tr>
  <td id="fork" class="important"><span class="date"> <code>int rseed(int seed)</code> </span><br /> </td>
  <td id="forkdescr" class="special"><span class="date">Seeds the random integer generator <code>rinter</code>.</span><br /> </td>
</tr>
<tr>
  <td id="fork" class="important"><span class="date"> <code>int rinter(int max)</code> </span><br /> </td>
  <td id="forkdescr" class="special"><span class="date">Returns a random integer between 0 and max.</span><br /> </td>
</tr>
<tr>
  <td id="fork" class="important"><span class="date"> <code>int trace(int mask)</code> </span><br /> </td>
  <td id="forkdescr" class="special"><span class="date">Enables tracing of Xv6 system calls which numbers match bits in mask.</span><br /> </td>
</tr>
<tr>
  <td id="fork" class="important"><span class="date"> <code>int sysinfo(struct sysinfo *info)</code> </span><br /> </td>
  <td id="forkdescr" class="special"><span class="date">Return system information - number of free bytes and number of procs.</span><br /> </td>
</tr>
</table>

<p><a name="refsystemcalls"></>
<h2>Reference: Xv6 System Calls</h2>
This section provides a reference of steps to add system calls to Xv6.
You do not have to study these steps prior to performing the lab, becuase 
the individual portions of the lab, contain instructions for performing these steps.
In later labs, when you have to add a system call, you can refer to these steps.
There is not a specific order to these steps; however, they all must be completed
in order to run Xv6 with the newly added system call.
In the following steps, a ficticious system call <tt><b>dosys</b></tt> is added.
  <ul>
    <li><p><b><tt>kernel/syscall.h</tt></b>: Add a syscall number to <tt>kernel/syscall.h</tt>. <tt>syscall.h</tt> is a sequence of C macros. 
     The <tt><b>dosys</b></tt> macro would be the following, where the number 22 is the next number.<br>
<tt>#define SYS_dosys  22</tt><br>
    </li> 
    <li><p><b><tt>kernel/syscall.c</tt></b>: Add <tt><b>dosys</b></tt> information to <tt>kernel/syscall.c</tt>. 
     <tt>syscall.c</tt> has the fucntion <tt>syscall</tt> that is called from <tt>trap</tt>. The function
     <tt>syscall</tt> determines which system call has been called, retrieves arguments, and makes the call.
     <tt>syscall.c</tt> has function prototypes for each system call and an array (<tt>syscalls[]</tt>) of function pointers
     that point to the various system calls. The array of function pointers uses the <tt>SYS_dosys</tt>
     number to place the address of the <tt>sys_dosys</tt> function in the array. The system call number
     is placed in register <tt>a7</tt> by <tt>usys.S</tt> prior to calling the function <tt>syscall</tt>.
     You can examine the code in <tt>syscall.c</tt> to see the following statements to call the correct
     system call.
<pre>
struct proc *p = myproc();          // proc that made system call
int num = p->trapframe->a7;         // retrieve system call num
p->trapframe->a0 = syscalls[num](); // call function, save ret val in reg a0
</pre>
    </li> 
    <li><p><b><tt>user/user.h</tt></b>: Add prototype for the <tt><b>dosys</b></tt> system call to <tt>user/user.h</tt> 
     The file <tt>user.h</tt> provides a seqence of function prototypes that serve as the API for system calls.
     User utility programs like <tt>ls</tt> and <tt>cat</tt> include <tt>user.h</tt> to access the API.
     The file <tt>user.h</tt> also has function prototypes for functions that are in 
     <tt>ulib.c</tt>. The <tt>ulib.c</tt> functions can be called directly, and the include  
     functions such as <tt>strcpy</tt> and <tt>printf</tt>.
    </li>
    <li><p><b><tt>user/usys.pl</tt></b>: Add a stub to <tt>user/usys.pl</tt>
     The <tt>Makefile</tt> invokes the perl script <tt>user/usys.pl</tt>, which produces <tt>user/usys.S</tt>,
     the actual system call stubs, which use the RISC-V <tt>ecall</tt> instruction to transition from user mode to the
     kernel mode. If you examine the code in <tt>usys.pl</tt>, you will discover the system call number is
     placed in register <tt>a7</tt> prior to executing the <tt>ecall</tt> instruction.</li>
    <li><p><b><tt>dosys</tt> Implementation</b>: <tt>kernel/sysproc.c</tt> is the entry point system calls. 
     For some system calls, the entire implementation is in <tt>sysproc.c</tt>. For example, you will place
     your implementation of <tt>rinter</tt> in the function <tt>sys_rinter()</tt> in <tt>sysproc.c</tt>.
     However, other system calls such as <tt>fork()</tt> the implementation is located in <tt>kernel/proc.c</tt>, and the 
     <tt>sys_fork()</tt> function simply calls <tt>fork()</tt>.
    <li><p><b>Testing/<tt>Makefile</tt></b>: You will have to create a user program to
     test your syscall implementation. Add <tt>$U/_dosystest</tt> to <tt>UPROGS</tt> in <tt>Makefile</tt>.
      To test your <tt><b>dosys</b></tt> system call, 
      create your test cases program in <tt>user/dosystest.c</tt>.
      Then add <tt>$U/_dosystest</tt> to <tt>UPROGS</tt> in <tt>Makefile</tt>.
     </li>
  </ul>

<p><a name="systemcallseq"></>
<h2>System Call - Sequence of Events</h2>
<p>A system call is different from a regular function call. A system call must transfer control from the user mode process
to the kernel mode OS. On the RISC-V architecture, this is accomplished with the <tt>ecall</tt> assembly instruction.
The <tt>ecall</tt> instruction generates a trap that must be handled by the OS. The following describes the sequence of events for the
<tt>rseed()</tt> system call. The sequence is the same for all system calls. Some system calls have more or less arguments.
<p>There are some ideas in this explanation of events that will require you to study virtual addresses and page tables, which is immediately after our system call study.
<ul>
<li>A user program is running as a process in user mode. The process calls <tt>rseed(555)</tt>.
<li>The function calling conventions of RISC-V places up to 8 arguments in 
registers <tt>a0</tt>, <tt>a1</tt>, <tt>a2</tt>, <tt>a3</tt>, <tt>a4</tt>, <tt>a5</tt>, <tt>a6</tt>, and <tt>a7</tt>. </li> 
<li>In calling <tt>rseed(555)</tt> places 555 in register <tt>a0</tt>, and generates a regular function call to <tt>rseed</tt>. 
<pre>
jalr rseed
</pre>
<li>When you add the stub <tt>entry("rseed");</tt> to <tt>user/usys.pl</tt> and the macro <tt>#define SYS_rseed 24</tt> to 
<tt>kernel/syscall.h</tt> you are adding the user level function <tt>rseed()</tt> and the system call number to Xv6.
<li>The stubs in <tt>user/usys.pl</tt> are processed by Perl to generate the file <tt>usys.S</tt>, which is a collection of assembly functions, one for each system call. In this example, the assembly function for <tt>rseed()</tt> looks like the following.
<pre>
rseed:
 li a7, SYS_rseed
 ecall
 ret
</pre>
<li>The code in <tt>usys.S</tt> is linked into every user program, which allows each user program to call system calls. 
<li>Notice that the assembly functions in <tt>usys.S</tt> are called in user mode. The <tt>ecall</tt> instruction transitions
to kernel mode.
<li>At the point of the <tt>ecall</tt> instruction in this example, the value 555 is in register <tt>r0</tt> and the value 
<tt>SYS_rseed</tt> is in register <tt>r7</tt>, which as defined for this example is 24.
<li>The <tt>ecall</tt> instruction generates a trap that changes the CPU mode from user to kernel. 
This trap must be handled by an OS trap handler.</li>
<li>During initialization, the function <tt>main</tt> in <tt>main.c</tt> calls functions in <tt>trap.c</tt> to install
the kernel trap vector (or address) in the <tt>stvec</tt> register. The function <tt>kernelvec</tt>.</li> handles interrupts when 
the CPU is in kernel mode. 
<li>When the CPU is in user mode, the <tt>stvec</tt> register contains the address of the <tt>Trampoline</tt>, which
is the user mode interrupt handler. The <tt>Trampoline</tt> code is in the file <tt>kernel/trampoline.S</tt>.
<li>The <tt>Trampoline</tt> code fits on one page, and there is only one copy of the <tt>Trampoline</tt> code in memory.
<li>Each process has the <tt>Trampoline</tt> mapped to the exact same address, which is placed in the <tt>stvec</tt> register.
<li>In addition to the <tt>Trampoline</tt> page, each process is allocated a trapframe page, which is used to store is registers when a trap occurs. Each process has the trapframe mapped to the same page.</li>
<li>When the <tt>ecall</tt> instruction generates the trap, it is processed by the kernel on the <tt>Trampoline</tt> page. 
At this point, the user pagetable is being used, but we are running in kernel mode. The user's <tt>Trampoline</tt> page is
marked such that it can execute in kernel mode. The <tt>Trampoline</tt> code saves the user's registers on the user's trapframe,
switches to the kernel's page table, and calls <tt>usertrap()</tt> located in <tt>trap.c</tt>.
<li><tt>usertrap()</tt> recoginizes this is a system call and calls the function <tt>syscall()</tt>
located in the file <tt>syscall.c</tt>.</li>
<li>If you examine <tt>syscall</tt>, you will see it retrieves the value of <tt>a7</tt> from the trapframe.
The user mode function <tt>rseed</tt> places the system call number in <tt>a7</tt>, which was saved on the trapframe by the
<tt>Trampoline</tt>
</li>
<li>The register <tt>a7</tt> has the system call number, which <tt>syscall</tt> uses to call the correct system call function.
In this case, it results in a call to <tt>sys_rseed()</tt>.</li>
<li>Notice the <tt>sys_rseed()</tt> does not have arguments, but <tt>rseed(555)</tt> has arguments.</li>
<li><tt>sys_rseed()</tt> retrieves its argument from register <tt>a0</tt> by calling <tt>argint</tt>, which is 
located in <tt>syscall.c</tt>. <tt>argint</tt> retrieves the register's value from the trapframe, which is
where the process's registers were saved when the trap occurred.</li>
<li>The CPU is now executing the kernel's code corresponding the system call.
<li>When the system call is complete, the code unwinds, eventually doing a return from trap which goes to the <tt>reg</tt> instruction shown above the the <tt>rseed()</tt> assembly function.
</ul>

<h2>Starting the Lab <script>g("easy")</script></h2>

<p>To start the lab, switch to the syscall branch:
  <pre>
  $ <kbd>git fetch</kbd>
  $ <kbd>git checkout syscall</kbd>
  $ <kbd>make clean</kbd>
  </pre>

<h2>Problem 1: Using gdb <script>g("easy")</script></h2>

<p>In many cases, print statements will be sufficient to debug your
kernel, but sometimes being able to single step through some assembly
code or inspecting the variables on the stack is helpful.

<p>To learn more about how to run GDB and the common issues that can
arise when using GDB, check out the following.
<ul>
<li><a href="gdb.html">GDB Sample Sessions</a> - definitely read this before starting the lab.
<li><A HREF="../gdb/gdb-refcard.pdf">GDB Reference Card</A></li>
<li><a href="../gdb/gdb_toc.html#SEC1">GDB Webpages TOC</a></li>
<li><a href="../gdb/gdb_25.html">GDB Webpages Index</a></li> 
</ul>

<p> To help you become familiar with gdb, run <kbd>make qemu-gdb</kbd> and
then fire up gdb in another window
(see <a href="gdb.html">GDB Sample Sessions</a>). Once you have two windows open, type in the gdb window:
<pre>
(gdb) <kbd>b syscall</kbd>
Breakpoint 1 at 0x80002142: file kernel/syscall.c, line 243.
(gdb) <kbd>c</kbd>
Continuing.
[Switching to Thread 1.2]

Thread 2 hit Breakpoint 1, syscall () at kernel/syscall.c:243
243     {
(gdb) <kbd>layout src</kbd>
(gdb) <kbd>backtrace</kbd>
</pre>

<p>The <tt>layout</tt> command splits the window in two, showing where
  gdb is in the source code. The <tt>backtrace</tt> prints out the
  stack backtrace</tt>.


  <div class="question">
    <p><b>1.</b> Looking at the backtrace output, which function
    called <tt>syscall</tt>?
  </div>

<p> Type <kbd>n</kbd> a few times to step pass <tt> struct proc *p = myproc();</tt>
    Once past this statement, type <kbd>p /x
    *p</kbd>, which prints the current process's <tt>proc struct</tt>
    (see <tt>kernel/proc.h></tt>) in hex.

<p> You will notice that a <tt>proc struct</tt> has a member <tt>trapframe</tt> which contains the proc's registers when a trap is processed.
    The value that <kbd>p /x *p</kbd> prints is the address of the <tt>trapframe</tt> member. To view the contents of <tt>trapframe</tt>,
    you must enter <kbd>p /x *p->trapframe</kbd>. This will show you the hex values of the registers saved on the trapframe.
    Alternatively, you can view the value of register a7, by entering <kbd>p /x (*p->trapframe)->a7</kbd>. Examine the use of parentheses
    in the command to disply the value of the register a7 in the <tt>trapframe</tt> structure.
    You may want to try entering <kbd>p /x *p->trapframe->a7</kbd> to help you better understand dereferencing C pointers.

  <div class="question">
    <p><b>2.</b> What is the value of <tt>p->trapframe->a7</tt> and what does that
    value represent?  (Hint: look <tt>user/initcode.S</tt>, the first
    user program xv6 starts.)
  </div>

<p>The processor is running in kernel mode, and we can print privileged
  registers such as <tt>sstatus</tt>
  (see <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V
    privileged instructions</a> for a description):

  <pre>
    (gdb) <kbd>p /x $sstatus</kbd>
  </pre>

   <div class="question">
     <p><b>3.</b> What was the previous mode that the CPU was in?
   </div>

<p>In the subsequent part of this lab (or in following labs), it may
  happen that you make a programming error that causes the xv6 kernel
  to panic. For example, replace the statement <tt>num = p->trapframe->a7;</tt>
with
  <tt>num = * (int *) 0;</tt>
  at the beginning of <tt>syscall</tt>, run <kbd>make
  qemu</kbd>, and you will see:
  <pre>
xv6 kernel is booting

hart 2 starting
hart 1 starting
scause 0x000000000000000d
sepc=0x000000008000207e stval=0x0000000000000000
panic: kerneltrap
  </pre>
Quit out of <tt>qemu</tt>.

<p>The privileged register <tt>scause</tt> contains the cause of the trap. When a trap is taken into S-mode, scause is written with a code indicating the event that caused the trap. Lookup what the value of 0xd (13) in <tt>scause</tt> means  (see <a href="https://github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V privileged instructions</a> for a description). 

<p>To track down the source of a kernel page-fault panic, search for
  the <tt>sepc</tt> value printed for the panic you just saw
  in the
  file <tt>kernel/kernel.asm</tt>, which contains the assembly for the
  compiled kernel.

  <div class="question">
    <p><b>4.</b> Write down the assembly instruction the kernel is panicing at.
    Which register corresponds to the varialable <tt>num</tt>?
  </div>

<p>To inspect the state of the processor and the kernel at the
faulting instruction, fire up gdb, and set a breakpoint at the
faulting <tt>epc</tt>, like this. Note, be sure the use the address you saw displayed in the <tt>panic: kerneltrap</tt>.
<pre>
(gdb) <kbd>b *0x000000008000207e</kbd>
Breakpoint 1 at 0x8000207e: file kernel/syscall.c, line 247.
(gdb) <kbd>layout asm</kbd>
(gdb) <kbd>c</kbd>
Continuing.
[Switching to Thread 1.3]

Thread 3 hit Breakpoint 1, syscall () at kernel/syscall.c:247
(gdb) <kbd>p /x $scause
</pre>

  <div class="question">
    <p><b>5.</b> Confirm that the faulting assembly instruction is the same as the
    one you found above.
  </div>

  <div class="question">
    <p><b>6.</b> Why does the kernel crash? Hint: look at figure 3-3 in the text;
    is address 0 mapped in the kernel address space?  What is the
    value in <tt>scause</tt> above? Does this value confirn why the kernel crashed.
    (See description of <tt>scause</tt>
    in <a href="https:n//github.com/riscv/riscv-isa-manual/releases/download/Priv-v1.12/riscv-privileged-20211203.pdf">RISC-V
    privileged instructions</a>)
  </div>

<p>Note that <tt>scause</tt> was printed by the kernel panic above,
  but often you need to look at additional info to track down the
  problem that caused the panic.  For example, to find out which user
  process was running when the kernel paniced, you can print out the
  process's name:
  <pre>
    (gdb) <kbd>p p->name</kbd>
  </pre>

    <div class="question">
      <p><b>7.</b> What is the name of the binary that was running when the kernel
      paniced?  What is its process id (<tt>pid</tt>)?
  </div>

<p>This concludes a brief introduction to tracking down bugs with gdb.

<p>This section and the links at the top of this section contain helpful information on gdb.

<h2>Problem 2: System calls for Random Integers  <script>g("moderate")</script></h2>

<p>
<div class="required">
  <p>In this problem you will add system calls <code>rseed</code> and <code>rinter</code> that
  seed a random integer generator and generate random integers. 
  This problem introduces you to the Xv6 system call mechanism.
  You'll create a
  new <tt>rseed</tt> system call that will seed the random integer generator. It shall
  take one argument, an integer "seed", that establishes the starting seed
  for the Pseudo Random Number Generator (PRNG).
  You'll create a new <tt>rinter</tt> system call that will return an pseudo random integer.
  It shall take one argument, an integer <tt>max</tt> such that the random number returned is 
  between 0 and <tt>max</tt> minus one. Both <tt>rseed</tt> and <tt>rinter</tt> shall return -1 on an error.
</div>

<p>The following are your requirements for <tt>rseed</tt> and <tt>rinter</tt>

<ul>

<li><p>Your implementation of <tt>rinter</tt> shall use a 
<a href="https://en.wikipedia.org/wiki/Linear_congruential_generator">Linear Congruential Generator </a>.
</li>

<li><p>You shall create a static variable to contain the <tt>rseedv</tt>, which shall be 0 by default.
</li>

<li><p>Calls to <tt>rseed(int seedvalue)</tt> shall update the value of <tt>rseedv</tt> to be <tt>seedvalue</tt>.
</li>

<li><p>One definition of a Linear Congruential Generator is defined by the algorithm 
<pre>
X<sub>n+1</sub> = (a * X<sub>n</sub> + b) bitwiseAnd m
</pre>
</li>

<li><p>The static variable <tt>rseedv</tt> shall be used for <tt>X</tt>.
</li>

<li><p>The number 1103515245 shall be used for <tt>a</tt>.
</li>

<li><p>The number 12345 shall be used for <tt>b</tt>.
</li>

<li><p>The C macro for <tt>MY_RAND_MAX</tt> shall be used for <tt>m</tt>.
<pre>
#define MY_RAND_MAX ((1U << 31) - 1)
</pre>
Notice the expression for <tt>MY_RAND_MAX</tt> results in <tt>0x7fffffff</tt>, which is the largest positive 32-bit number. 
The C bitwise and operator is a single </tt>&</t>.
When you use a bitwise and in the expression
<pre>
(1103515245 * rseedv + 12345) & MY_RAND_MAX
</pre>
you are creating a positive number.
</li>

</ul>

<h3>Some Hints</h3>
  <ul>

    <li><p>Add <tt>$U/_randomtest</tt> to <tt>UPROGS</tt> in <tt>Makefile</tt></li>
    <li><p>Run <kbd>make qemu</kbd> and you will see that the
	compiler cannot compile <tt>user/randomtest.c</tt>, because the
	user-space stubs for the system calls don't exist yet:</li> 
    <li><p>Add prototypes for the system calls to <tt>user/user.h</tt>, </li>
    <li><p>Add stubs to <tt>user/usys.pl</tt>, and </li>
    <li><p>Add syscall numbers to <tt>kernel/syscall.h</tt>. </li> 
		<li><p>The <tt>Makefile</tt> invokes the perl
	script <tt>user/usys.pl</tt>, which produces <tt>user/usys.S</tt>,
	the actual system call stubs, which use the
	RISC-V <tt>ecall</tt> instruction to transition to the
	kernel. </li>
    <li><p>Once you fix the compilation issues such that <kbd>make qemu</kbd> successfully makes,
	you can run <kbd>randomtest 555</kbd>; but it will fail
	because you haven't implemented the system calls in the kernel
	yet.</li>

    <li><p>Add a <tt>sys_rseed()</tt> function
	in <tt>kernel/sysproc.c</tt> that implements the new system
	call by assigning its argument to the static variable <tt>rseedv</tt>.
      <ul>
      <li><tt>sys_rseed()</tt> is called when a user program calls <tt>rseed(555)</tt>.</li>
      <li>When calling functions with arguments, up to 6 arguments are placed into
          registers <tt>a0</tt>, <tt>a1</tt>, <tt>a2</tt>, <tt>a3</tt>, <tt>a4</tt>, and <tt>a5</tt>. </li> 
      <li>Calling <tt>rseed(555)</tt> places 555 in register <tt>a0</tt>, 
          places the system number associated with <tt>rseed</tt> in register <tt>a7</tt>,
          and executes the assembly instruction <tt>ecall</tt>.</li>
      <li>The <tt>ecall</tt> instruction generates a trap that changes the CPU mode from user to supervisor.</li>
      <li>During initialization, the function <tt>main</tt> in <tt>main.c</tt> calls <tt>trapinithart</tt> to install
          the kernel trap vector, which is the function <tt>kernelvec</tt>.</li>
      <li>The function <tt>kernelvec</tt> is an assembly function in <tt>kernelvec.S</tt> that saves registers
          on the trapframe and calls the fuction <tt>kerneltrap</tt>.</li>
      <li>Each process is allocated a trapframe, which is used to store is registers when a trap occurs.</li>
      <li><tt>kerneltrap</tt> is a function in <tt>trap.c</tt></li>
      <li>The trap is processed by the kernel and <tt>kerneltrap</tt> calls the function <tt>syscall</tt>
          located in the file <tt>syscall.c</tt>.</li>
      <li>If you examine <tt>syscall</tt>, you will see it retrieves the value of <tt>a7</tt> from the trapframe.</li>
      <li>The register <tt>a7</tt> has the system call number, which <tt>syscall</tt> uses to call the correct system call function.
          In this case, it results in a call to <tt>sys_rseed()</tt>.</li>
      <li>Notice the <tt>sys_rseed()</tt> does not have arguments, but <tt>rseed(555)</tt> has arguments.</li>
      <li><tt>sys_rseed()</tt> retrieves its argument from register <tt>a0</tt> by calling <tt>argint</tt>, which is 
          located in <tt>syscall.c</tt>. <tt>argint</tt> retrieves the register's value from the trapframe, which is
          where the process's registers were saved when the trap occurred.</li>
      <li><tt>argint</tt> is called in many of the <tt>sys_</tt> functions. One of the easiest to examine is 
          <tt>sys_exit</tt>. The <tt>exit(1)</tt> system call has one argument, which is an integer. 
          Study how <tt>sys_exit</tt> calls <tt>argint</tt>.</li> 
     
      </ul>
    </li>
    <li><p>Add a <tt>sys_rinter()</tt> function
	in <tt>kernel/sysproc.c</tt> that implements the new system
	call by using the Linear Congruential General algorithm defined above.
    </li>
    <li><p>Modify the <tt>syscall()</tt> function
	in <tt>kernel/syscall.c</tt> to include the information needed to make the system calls. 
    Follow the pattern of exising system calls.</li>

    <li><p>Once you updated <tt>kernel/sysproc.c</tt> and <tt>kernel/syscall.c</tt>, perform a <kbd>make qemu</kbd>, and run <kbd>$ randomtest 555</kbd> as a utility program in Xv6 to see if you have implemented it correctly.
    Use the sample outputs provided above for comparisons.
    </li>

  </ul>
<h3>Testing</h3>
<p>We provide a <tt>randomtest</tt> user-level program that calls your
  <tt>rseed</tt> and <tt>rinter</tt> system calls (see <tt>user/randomtest.c</tt>).
  When you're done, you should see output like this:

<pre>
$ randomtest 555
40
69
74
3
60
1
10
39
96
49
$ randomtest 101
42
79
84
53
94
79
44
9
10
19
$ randomtest 43
24
33
62
63
88
1
26
59
52
89
</pre>
</li>

    <div class="question">
      <p><b>8.</b> The system calls for random numbers were a nice introduction to system calls.
      You learned how to add OS system calls to the Xv6 OS.
      Do they have to be system calls? Examine the files <tt>kernel/string.c</tt> and <tt>user/umalloc.c</tt> and
      how they fit into Xv6 before answering this question. 
  </div>

<h2>Problem 3: System call tracing <script>g("moderate - solution code provided")</script></h2>

<p>
<div class="required">
  <p>In this problem you will add a system call tracing feature that
  may help you when debugging later labs.  You'll create a
  new <tt>trace</tt> system call that will control tracing. It should
  take one argument, an integer "mask", whose bits specify which
  system calls to trace.  For example, to trace the fork system call,
  a program calls <tt>trace(1 << SYS_fork)</tt>, where <tt>SYS_fork</tt> is a
  syscall number from <tt>kernel/syscall.h</tt>. You have to modify
  the xv6 kernel to print out a line when each system call is about to
  return, if the system call's number is set in the mask.
  The line should contain the
  process id, the name of the system call and the
  return value; you don't need to print the system call
  arguments. The <tt>trace</tt> system call should enable tracing
  for the process that calls it and any children that it subsequently forks,
  but should not affect other processes.
</div>

<p>Let's first consider the <tt>int trace(int)</tt> function prototype
  that is added to <tt>user.h</tt>. The return code is 0 for success and
  -1 for failure. The argument is an integer, which is a 32-bit quantity.
  Each bit corresponds to a system call number, which is defined in <tt>syscall.h</tt>. 
  For example, bit 1 specifies
  to trace <tt>fork</tt> system calls because <tt>fork</tt> has number 1
  as its system call number. This means if you make a call <tt>trace(2)</tt>,
  you are tracing <tt>fork</tt> system calls because 2 has bit 1 set. 
  Another example is <tt>trace(0x20)</tt>
  traces <tt>read</tt> system calls because <tt>read</tt> has number 5 
  as its system call number and 0x20 has bit 5 set. The C expression <tt>1<<5</tt>
  results in the number 0x20, because 1 is shifted 5 bits to the left.
  If you want to trace both <tt>fork</tt> and <tt>read</tt> system calls, 
  you would call <tt>trace(0x22)</tt> which sets bits 1 and 5.

<p>When calling the <tt>trace</tt> user program from the command line, the
  examples show the first parameter as in decimal integer. The samples provided
  in the Testing section 
  discuss translating this decimal integar parameter to specific system calls.

<h3>Some Hints</h3>

<p>Many of these hints are similar (but maybe briefer) to the hints for the system calls for random numbers.

  <ul>

    <li><p>Add <tt>$U/_trace</tt> to <tt>UPROGS</tt> in <tt>Makefile</tt>. The file <tt>user/trace.c</tt> contains the test cases for the <tt>trace</tt> system call.

    <li><p>You could run <kbd>make qemu</kbd> and you will see that the
	compiler cannot compile <tt>user/trace.c</tt>, because the
	user-space stubs for the system call don't exist yet.
    <li><p>Add a prototype for the system call to <tt>user/user.h</tt>. 
<p>
<tt>
<kbd>
int trace(int);
</kbd>
</tt>

    <li><p>Add a stub
	to <tt>user/usys.pl</tt>, and a syscall number
	to <tt>kernel/syscall.h</tt>.  The Makefile invokes the perl
	script <tt>user/usys.pl</tt>, which produces <tt>user/usys.S</tt>,
	the actual system call stubs, which use the
	RISC-V <tt>ecall</tt> instruction to transition to the
	kernel. 
<p>
<tt>
<kbd> entry("trace"); </kbd> &larr; ADDED TO user/usys.pl<br>
<kbd> #define SYS_trace 22 </kbd> &larr; ADDED TO kernel/syscall.h
</tt>

    <li><p>Once you fix the compilation issues, you could 
	run <kbd>trace 32 grep hello README</kbd>; but it will fail
	because you haven't implemented the system call in the kernel
	yet.

<li><p>Update the <tt>kernel/proc.h</tt> file by adding a new member <tt>int mask</tt> 
to the <tt>struct proc</tt> structure.</li>
<p>The following is the code for the updated <tt>struct proc</tt> structure in <tt>kernel/proc.h</tt>.
You are only adding one line.
<pre>
struct proc {
  struct spinlock lock;

  // p->lock must be held when using these:
  enum procstate state;        // Process state
  void *chan;                  // If non-zero, sleeping on chan
  int killed;                  // If non-zero, have been killed
  int xstate;                  // Exit status to be returned to parent's wait
  int pid;                     // Process ID

<kbd>&nbsp;&nbsp;int mask; // for syscall trace</kbd><b> &leftarrow; add this line </b>

  // wait_lock must be held when using this:
  struct proc *parent;         // Parent process

  // these are private to the process, so p->lock need not be held.
  uint64 kstack;               // Virtual address of kernel stack
  uint64 sz;                   // Size of process memory (bytes)
  pagetable_t pagetable;       // User page table
  struct trapframe *trapframe; // data page for trampoline.S
  struct context context;      // swtch() here to run process
  struct file *ofile[NOFILE];  // Open files
  struct inode *cwd;           // Current directory
  char name[16];               // Process name (debugging)
};
</pre>
</li>
    <li><p>Add a <tt>sys_trace()</tt> function
	in <tt>kernel/sysproc.c</tt> that implements the new system
	call by remembering its argument in a new variable in
	the <tt>proc</tt> structure (see <tt>kernel/proc.h</tt>). The
	functions to retrieve system call arguments from user space are
	in <tt>kernel/syscall.c</tt>, and you can see examples
        of their use in <tt>kernel/sysproc.c</tt>.
  This programming is just like the random number system calls,
  which contain additional information on this step.
   </li>

   <p>The following is the code for <tt>sys_trace()</tt>, which is added to <tt>kernel/sysproc.c</tt>.
<pre>
<kbd>
uint64
sys_trace(void)
{
  int n;
  argint(0, &n);
  myproc()->mask = n;
  return 0;
}
</kbd>
</pre>
   </li>

    <li><p>Modify <tt>fork()</tt> (see <tt>kernel/proc.c</tt>) to copy
    the trace mask from the parent to the child process. 
    <tt>fork()</tt> creates a child process, which is identical to its
    parent. Both the parent and child have <tt>struc proc</tt> that define
    the process attributes. The parent has a trace mask stored in its
    <tt>struct proc</tt>, which is what you added in the previous step.
    You must copy this trace mask to the child.
    </li>
    <p>The following is the code of a modified <tt>fork()</tt>, which is in <tt>kerenl/proc.c</tt>. You are only adding one line.
<pre>
int
fork(void)
{
  int i, pid;
  struct proc *np;
  struct proc *p = myproc();

  // Allocate process.
  if((np = allocproc()) == 0){
    return -1;
  }

<kbd>&nbsp;&nbsp;// Copy mask for syscall trace</kbd> <b> &leftarrow; add this line</b></tt>
<kbd>&nbsp;&nbsp;np->mask = p->mask;</kbd> <b> &leftarrow; add this line</b></tt>

  // Copy user memory from parent to child.
  if(uvmcopy(p->pagetable, np->pagetable, p->sz) &lt; 0){
    freeproc(np);
    release(&np->lock);
    return -1;
  }
  np->sz = p->sz;

  // copy saved user registers.
  *(np->trapframe) = *(p->trapframe);

  // Cause fork to return 0 in the child.
  np->trapframe->a0 = 0;

  // increment reference counts on open file descriptors.
  for(i = 0; i < NOFILE; i++)
    if(p->ofile[i])
      np->ofile[i] = filedup(p->ofile[i]);
  np->cwd = idup(p->cwd);

  safestrcpy(np->name, p->name, sizeof(p->name));

  pid = np->pid;

  release(&np->lock);

  acquire(&wait_lock);
  np->parent = p;
  release(&wait_lock);

  acquire(&np->lock);
  np->state = RUNNABLE;
  release(&np->lock);

  return pid;
}
</pre>
    </li>


    <li><p>Modify the <tt>syscall()</tt> function
	in <tt>kernel/syscall.c</tt> to print the trace output. You will need to add an array of syscall names to index into.
    Make sure that the indices of the array use the <tt>SYS_fork</tt> names defined in <tt>syscall.h</tt>. For example
<pre>
static char *syscall_name[] = {
[SYS_fork]    "fork",
[SYS_exit]    "exit",
...
</pre>

    </li><p>The format for each line printed by your trace in <tt>syscall()</tt> is
<pre>
"%d: syscall %s -> %d\n" pid, syscallName, syscallReturnValue"
</pre>
If you study the code in <tt>syscall()</tt>, I am sure you can find the variables that 
correspond to <tt>pid</tt>, <tt>syscallName</tt>, and <tt>syscallReturnValue</tt>.
These variables may be members of structures.<br><br>
<li>The following is the code for the <tt>syscall()</tt> modifications.
This does not show the entire code for <tt>syscall.c</tt>. Just enough to show the modifications, which are in green font.
Be sure that the order of your <tt>syscall_name[]</tt> matches the order of your system call numbers.
<br><br>
<tt><kbd>static char *syscall_name[] = {</kbd></tt><br>
<tt><kbd>[SYS_fork]    "fork",</kbd></tt><br>
<tt><kbd>[SYS_exit]    "exit",</kbd></tt><br>
<tt><kbd>[SYS_wait]    "wait",</kbd></tt><br>
<tt><kbd>[SYS_pipe]    "pipe",</kbd></tt><br>
<tt><kbd>[SYS_read]    "read",</kbd></tt><br>
<tt><kbd>[SYS_kill]    "kill",</kbd></tt><br>
<tt><kbd>[SYS_exec]    "exec",</kbd></tt><br>
<tt><kbd>[SYS_fstat]   "fstat",</kbd></tt><br>
<tt><kbd>[SYS_chdir]   "chdir",</kbd></tt><br>
<tt><kbd>[SYS_dup]     "dup",</kbd></tt><br>
<tt><kbd>[SYS_getpid]  "getpid",</kbd></tt><br>
<tt><kbd>[SYS_sbrk]    "sbrk",</kbd></tt><br>
<tt><kbd>[SYS_sleep]   "sleep",</kbd></tt><br>
<tt><kbd>[SYS_uptime]  "uptime",</kbd></tt><br>
<tt><kbd>[SYS_open]    "open",</kbd></tt><br>
<tt><kbd>[SYS_write]   "write",</kbd></tt><br>
<tt><kbd>[SYS_mknod]   "mknod",</kbd></tt><br>
<tt><kbd>[SYS_unlink]  "unlink",</kbd></tt><br>
<tt><kbd>[SYS_link]    "link",</kbd></tt><br>
<tt><kbd>[SYS_mkdir]   "mkdir",</kbd></tt><br>
<tt><kbd>[SYS_close]   "close",</kbd></tt><br>
<tt><kbd>[SYS_trace]   "trace",</kbd></tt><br>
<tt><kbd>[SYS_sysinfo] "sysinfo",</kbd></tt><br>
<tt><kbd>[SYS_rseed]   "rseed",</kbd></tt><br>
<tt><kbd>[SYS_rinter]  "rinter",</kbd></tt><br>
<tt><kbd>};</kbd></tt><br>
<pre>
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  //num = * (int *) 0;
  num = p->trapframe->a7;
  if(num > 0 && num &lt; NELEM(syscalls) && syscalls[num]) {
    // Use num to lookup the system call function for num, call it,
    // and store its return value in p->trapframe->a0
    p->trapframe->a0 = syscalls[num]();
</pre>
<tt><kbd>&nbsp;&nbsp;&nbsp;&nbsp;// core code for syscall trace</kbd></tt><br>
<tt><kbd>&nbsp;&nbsp;&nbsp;&nbsp;if((1&lt;&lt;num) & p->mask){</kbd></tt><br>
<tt><kbd>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf("%d: syscall %s -> %d\n", p->pid, syscall_name[num], p->trapframe->a0);</kbd></tt><br>
<tt><kbd>&nbsp;&nbsp;&nbsp;&nbsp;}</kbd></tt><br>
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
</pre>

  </ul>

<h3>Testing</h3>
<p>We provide a <tt>trace</tt> user-level program that runs another
  program with tracing enabled (see <tt>user/trace.c</tt>). 
Do not simply run the <tt>trace</tt> program. Study the code in <tt>user/trace.c</tt>.
When the <tt>trace</tt> program is run, it is a child process of the shell.
You will see that the <tt>trace</tt> user program calls the <tt>trace()</tt> system call with the mask provided.
This sets the <tt>mask</tt> member of the <tt>struct proc</tt> to be the mask. This is for the <tt>trace</tt> process.
The <tt>trace</tt> process then calls <tt>exec()</tt> to execute the the program and arguments.
This program is a child of the <tt>trace</tt> process, but the <tt>fork()</tt> function copies its parents mask 
to the child. When the program argument executes it has its trace <tt>mask</tt> set which prints the trace results.
<p>
When you're
  done, you should see output like this:

<ul>
<li><p>In the first example trace runs grep tracing just the
read system call. The 32 is <tt>1&lt;&lt;SYS_read</tt>. 
<pre>
$ trace 32 grep hello README
3: syscall read -> 1023
3: syscall read -> 966
3: syscall read -> 70
3: syscall read -> 0
$
</pre>
<li>In the second example, trace runs grep while tracing all system calls; the
2147483647 has all 31 low bits set. 
<pre>
$ trace 2147483647 grep hello README
4: syscall trace -> 0
4: syscall exec -> 3
4: syscall open -> 3
4: syscall read -> 1023
4: syscall read -> 966
4: syscall read -> 70
4: syscall read -> 0
4: syscall close -> 0
$
</pre>
<li>In the third example, the program isn't traced, so no trace output is printed. 
<pre>
$ grep hello README
$
</pre>
<li> In the fourth example
the fork system calls of all the descendants of the <tt>forkforkfork</tt> test
in <tt>usertests</tt> are being traced. Your solution is correct if your
program behaves as shown above (though the process IDs may be
different).
<pre>
$ trace 2 usertests forkforkfork
usertests starting
test forkforkfork: 407: syscall fork -> 408
408: syscall fork -> 409
409: syscall fork -> 410
410: syscall fork -> 411
409: syscall fork -> 412
410: syscall fork -> 413
409: syscall fork -> 414
411: syscall fork -> 415
...
$
</pre>
</ul>

<h2>Problem 4: Sysinfo <script>g("moderate - solution code provided")</script></h2>

<p>
<div class="required">
  <p>In this problem you will add a system call, <tt>sysinfo</tt>,
  that collects information about the running system.  The system call
  takes one argument: a pointer to a <tt>struct sysinfo</tt>
  (see <tt>kernel/sysinfo.h</tt>). The kernel should fill out the
  fields of this struct: the <tt>freemem</tt> field should be set
  to the number of bytes of free memory, and the <tt>nproc</tt>
  field should be set to the number of processes whose <tt>state</tt>
  is not <tt>UNUSED</tt>.
  We provide a test program <tt>sysinfotest</tt> that you can use to test your implementation
</div>

<h3>Some Hints</h3>
<ul>

<li><p>Add <tt>$U/_sysinfotest</tt> to UPROGS in Makefile. The file <tt>sysinfotest.c</tt> contains test cases for this problem.

<li><p>You could run <kbd>make qemu</kbd>; but <tt>user/sysinfotest.c</tt> will
  fail to compile because it calls the <tt>sysinfo</tt> system call which is not available yet. 
</li>
<li>Add the system call <tt>sysinfo</tt>, following the same
  steps as in the previous problems of this lab. You can refer 
  to  <a href="#refsystemcalls" >Reference: Xv6 System Calls</a> for the steps.
  For one of the steps, you must declare the prototype for
  <tt>sysinfo(struct sysinfo *)</tt> in <tt>user/user.h</tt>, but since <tt>sysinfo</tt>
  has a <tt>struct sysinfo *</tt> argument, you need predeclare the existence
  of <tt>struct sysinfo</tt> in order for the prototype to compile correclty. 
  Place the following as the second line in the file <tt>user/user.h</tt>.
  <p>
  <tt>
  <kbd>
    struct sysinfo;
  </kbd>
  </tt>
  <p>Now you can place the following <tt>sysinfo</tt> function prototype in the list of system calls in the file <tt>user/user.h</tt>.
  <p>
  <tt>
  <kbd>
    int sysinfo(struct sysinfo *);
  </kbd>
  </tt>
</li>

<li><p>Add a stub
	to <tt>user/usys.pl</tt>, and a syscall number
	to <tt>kernel/syscall.h</tt>.  The Makefile invokes the perl
	script <tt>user/usys.pl</tt>, which produces <tt>user/usys.S</tt>,
	the actual system call stubs, which use the
	RISC-V <tt>ecall</tt> instruction to transition to the
	kernel. 
</li>
<p>
<tt>
<kbd> entry("sysinfo"); </kbd> &larr; ADDED TO user/usys.pl<br>
<kbd> #define SYS_sysinfo 23 </kbd> &larr; ADDED TO kernel/syscall.h
NOTE: The number 23 will depend on what order you have created your system calls.
</tt>

<li>The definition of <tt>struct sysinfo</tt> is in the file <tt>kernel/sysinfo.h</tt>. When you add the funtion, <tt>sys_sysinfo()</tt> to the file <tt>kernel/sysproc.c</tt>, you must include <tt>sysinfor.h</tt>. The contents of <tt>struct sysinfo</tt> is the fiollowing.
<pre>
<kbd>
struct sysinfo {
  uint64 freemem;   // amount of free memory (bytes)
  uint64 nproc;     // number of process
};
</kbd>
</pre>

    <li><p>Once you fix the compilation issues, you could 
	run <kbd>sysinfotest</kbd>; but it will fail
	because you haven't implemented the system call in the kernel
	yet.

<li>Once you fix the compilation issues, <kbd>make qemu</kbd> will create a system with <tt>sysinfotest</tt>, but it will not run
  because you haven't implemented the system call in the kernel yet.
</li>

<li><p>Your <tt>sysinfo</tt> will need some helper functions in the kernel.
These functions are not system calls because only the kernel (namely <tt>sysinfo</tt>) calls them; however,
you must put their function prototypes in <tt>defs.h</tt>. Functions within the kernel include <tt>defs.h</tt> to get the various kernel function prototypes needed to compile.
<ul>
<li><tt>kernel/defs.h</tt> - place this function prototypes for <tt>get_freemen()</tt> and <tt>get_nproc()</tt> in <tt>kernel/defs.h</tt>.
You will notice <tt>kernel/defs.h</tt> is organized by the <tt>.c</tt> files in the kernel. 
<p>Locate the <tt>kalloc.c</tt> section and add the following prototype. Follow the formatting of the file.
<p>
  <tt>
  <kbd>
int             get_freemem(void);
  </kbd>
  </tt>
<p>Locate the <tt>proc.c</tt> section and add the following prototype. Follow the formatting of the file.
<p>
  <tt>
  <kbd>
int             get_nproc(void);
  </kbd>
  </tt>

<li><tt>get_freemem()</tt> - place this function in <tt>kernel/kalloc.c</tt>.
Implementing this function requires you to walk the free memory list
counting the free bytes. It returns the number of bytes of free memory.
<ul>
<li>The free memory is pointed to by the variable <tt>kmem.freelist</tt>, which 
is type <tt>struct run *</tt>, which is defined in <tt>kalloc.c</tt>  as follows.
<pre>
struct run {
  struct run *next;
};
</pre>
<li>You must traverse the singly linked-list to compute the number of free bytes.
<li>The free list is a list of free pages, where each page is <tt>PGSIZE</tt> bytes.
<li>The macro <tt>PGSIZE</tt> is defined to be 4096 in the file <tt>riscv.h</tt>.
<li>Notice that the free list has a lock <tt>kmem.lock</tt> that you must
<tt>acquire</tt> before traversing the free list and <tt>release</tt> after
traversing the free list.
We will study locks in detail shortly.
</ul>
<p>The following is the code for <tt>get_freemem()</tt>. It is a basic linked-list traversal algorithm that accumulates the total number of free bytes. You can place this at the bottom of the file <tt>kalloc.c</tt>.
<pre>
<kbd>
// get the number of bytes of free memory
int
get_freemem()
{
  int bytes = 0;
  struct run *p = kmem.freelist;
  acquire(&kmem.lock);
  while(p){
    bytes += PGSIZE;
    p = p->next;
  }
  release(&kmem.lock);
  return bytes;
}
</kbd>
</pre>
<li><tt>get_nproc()</tt> - place this function in <tt>kernel/proc.c</tt>.
Implementing this function requires you to iterate through the procs
counting those that are not <tt>UNUSED</tt>. It returns the number of
procs that are not <tt>UNUSED</tt>.
<ul>
<li>Procs are stored in the array <tt>struct proc proc[NPROC];</tt>.
<li>You must itterate through the array <tt>struct proc proc</tt> 
counting the procs that are not <tt>UNUSED</tt>.
</ul>
<p>The following is the code for <tt>get_nproc()</tt>. You can place this at the bottom of the file <tt>proc.c</tt>.

<pre>
<kbd>
// get the number of processes whose state is not UNUSED
int
get_nproc()
{
  int n = 0;
  for(int i=0; i&lt;NPROC; i++){
    if(proc[i].state != UNUSED){
      n++;
    }
  }
  return n;
}
</kbd>
</pre>
</ul>
</li>

<li><p><tt>sysinfo</tt> must copy a <tt>struct sysinfo</tt> back to user
  space; see <tt>sys_fstat()</tt> (<tt>kernel/sysfile.c</tt>)
  and <tt>filestat()</tt> (<tt>kernel/file.c</tt>) for examples of how
  to do that using <tt>copyout()</tt>.
</li>

<li>The following is the code for <tt>sys_sysinfo()</tt>.
<pre>
<kbd>
uint64
sys_sysinfo(void)
{
  struct sysinfo info;
  info.freemem = get_freemem();
  info.nproc = get_nproc();

  uint64 addr;
  argaddr(0, &addr);
  // kernel cannot directly access user space. use copyout()
  return copyout(myproc()->pagetable, addr, (char*)&info, sizeof(info));
}
</kbd>
</pre>

</ul>

    <div class="question">
      <p><b>9.</b> Why must the kernel call <tt>copyout</tt>?
  </div>

<h3>Testing</h3>
<p>We have provided <tt>user/sysinfotest.c</tt> to test the <tt>sysinfo</tt> implementationa, 
and it is an execellent example of how to test. 
The code in <tt>user/sysinfotest.c</tt> requires some thought to understand.
<ul>
<li>The function <tt>testcall()</tt> makes sure that <tt>sysinfo()</tt> succeeds with a valid address and fails with a bad address.
<li>The function <tt>testmem()</tt> first counts all of the free pages of memory. It does this by calling <tt>countfree()</tt>, which repeatedly consumes all of the free pages by calling the <tt>sbrk()</tt> function, counting the pages as they are aquired. After <tt>countfree()</tt> has consumed all of the free memory, it calls <tt>sysinfo()</tt>, which should return 0 bytes of free memory. Then <tt>countfree()</tt> returns all of the pages it has acquired and calls <tt>sysinfo()</tt> again. This time <tt>sysinfo()</tt> should return the number of pages counted.
<li>The function <tt>testproc()</tt> calls <tt>sysinfo()</tt> to determine how many process are not <tt>UNUSED</tt>. Then <tt>testproc()</tt> calls <tt>fork()</tt> to create a child process. Then <tt>testproc()</tt> calls <tt>sysinfo()</tt> again, which should return one more process than before. After the child process finishes, <tt>testproc()</tt> calls <tt>sysinfo()</tt> again, which should return the original number of processes.
</ul>
Running <tt>sysinfotest</tt> is rather boring. You should be patient for it to terminate.
<pre>
xv6 kernel is booting

hart 2 starting
hart 1 starting
init: starting sh
$ <kbd>sysinfotest</kbd>
sysinfotest: start
sysinfotest: OK
$ 
</pre>
<p><a name="submit"></>
<h2>Submit the lab</h2>

<p><b>This completes the lab.</b> 

Read <a href="../labsubmissions.html" >Lab Submissions</a> for instructions on how
to submit your lab.


</body>
</html>
